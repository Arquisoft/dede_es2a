[[section-building-block-view]]


== Vista de bloques de construcción

[role="arc42help"]
****
.Content
The building block view shows the static decomposition of the system into building blocks (modules, components, subsystems, classes,
interfaces, packages, libraries, frameworks, layers, partitions, tiers, functions, macros, operations,
datas structures, ...) as well as their dependencies (relationships, associations, ...)

This view is mandatory for every architecture documentation.
In analogy to a house this is the _floor plan_.

.Motivation
Maintain an overview of your source code by making its structure understandable through
abstraction.

This allows you to communicate with your stakeholder on an abstract level without disclosing implementation details.

.Form
The building block view is a hierarchical collection of black boxes and white boxes
(see figure below) and their descriptions.

image:05_building_blocks-EN.png["Hierarchy of building blocks"]

*Level 1* is the white box description of the overall system together with black
box descriptions of all contained building blocks.

*Level 2* zooms into some building blocks of level 1.
Thus it contains the white box description of selected building blocks of level 1, together with black box descriptions of their internal building blocks.

*Level 3* zooms into selected building blocks of level 2, and so on.
****

=== Sistema General de Caja Blanca
En este apartado vamos a estudiar más a fondo la API de nuestra aplicación con un sistema de cajas negras (función de los elementos) y cajas blancas (funcionamiento interno de los elementos)
Este sería el diagrama que indica las entidades que componen nuestra aplicación así como las interfaces que utilizan.
image:bloqueConstruccion.png["Hierarchy of building blocks"]

[role="arc42help"]
****
Here you describe the decomposition of the overall system using the following white box template. It contains

 * an overview diagram
 * a motivation for the decomposition
 * black box descriptions of the contained building blocks. For these we offer you alternatives:

   ** use _one_ table for a short and pragmatic overview of all contained building blocks and their interfaces
   ** use a list of black box descriptions of the building blocks according to the black box template (see below).
   Depending on your choice of tool this list could be sub-chapters (in text files), sub-pages (in a Wiki) or nested elements (in a modeling tool).


 * (optional:) important interfaces, that are not explained in the black box templates of a building block, but are very important for understanding the white box.
Since there are so many ways to specify interfaces why do not provide a specific template for them.
 In the worst case you have to specify and describe syntax, semantics, protocols, error handling,
 restrictions, versions, qualities, necessary compatibilities and many things more.
In the best case you will get away with examples or simple signatures.

****


[role="arc42help"]
****
Insert your explanations of black boxes from level 1:

If you use tabular form you will only describe your black boxes with name and
responsibility according to the following schema:

[cols="1,2" options="header"]
|===
| **Name** | **Responsibility**
| _<black box 1>_ | _<Text>_
| _<black box 2>_ | _<Text>_
|===



If you use a list of black box descriptions then you fill in a separate black box template for every important building block .
Its headline is the name of the black box.
****

=== Usuario (caja negra)
.Intención/responsabilidad
Usuario gestiona a los clientes que interactúan con nuestra aplicación. No se almacenará demasiada información de los mismos, ya que la intención de nuestro sitio es extraer únicamente los datos necesarios así como puede ser la dirección pero sin necesidad de disponer de ella en nuestro almacenamiento (BD), sino en el sistema de PODs. No utiliza ninguna interfaz (API) externa.


=== Juguete (caja negra)
.Intención/responsabilidad
Juguete se encarga de administrar a los productos que forman parte de nuestro sitio web.

.Interfaces
[options="header",cols="1,2"]
|===
|Interfaz|Descripción
| _Cloudinary_ | _Almacén que se encargará de guardar las imágenes de los juguetes en la nube, de tal manera que tengamos un almacén seguro._ 
|===

=== Pedido (caja negra)
.Intención/responsabilidad
Pedido sería la entidad que simula a los pedidos de nuestra aplicación, ya sea los productos que contenga, como su cantidad, los gastos de envío en función de la distancia...

.Interfaces
[options="header",cols="1,2"]
|===
|Interfaz|Descripción
| _GeoCode_ | _Extrae las coordenadas de una dirección para así hacer posible el calculo de los gasto de envío respecto a las coordenadas de nuestra tienda._ 
|===



[role="arc42help"]
****
Here you describe <black box 1>
according the the following black box template:

* Purpose/Responsibility
* Interface(s), when they are not extracted as separate paragraphs. This interfaces may include qualities and performance characteristics.
* (Optional) Quality-/Performance characteristics of the black box, e.g.availability, run time behavior, ....
* (Optional) directory/file location
* (Optional) Fulfilled requirements (if you need traceability to requirements).
* (Optional) Open issues/problems/risks

****




==== Bloque de construcción - Nivel 2
Nosotros decidimos organizar nuestra REST API a través de modelos que definen las entidades tal y como serán en la base de datos, repositorios que serán los encargados de trabajar con la misma y por último los routes que se encargan de gestionar las peticiones.

[role="arc42help"]
****
Here you can specify the inner structure of (some) building blocks from level 1 as white boxes.

You have to decide which building blocks of your system are important enough to justify such a detailed description.
Please prefer relevance over completeness. Specify important, surprising, risky, complex or volatile building blocks.
Leave out normal, simple, boring or standardized parts of your system
****

=== Usuario (caja blanca)
image:UsuarioBloqueConstruccion.png["Hierarchy of building blocks"]

Modelo usuario se encarga de definir la estructura que el usuario tendrá en nuestra base de datos. Este modelo es usado por RepositorioUsuario, ya que este será necesario para acciones como pueden ser añadir a un usuario. Por último, el routeUsuario que es el que se encarga de gestionar las peticiones recibidas tendrá que comunicarse con el repositorio, ya que estas peticiones requerirán acceso a datos.

=== Juguete (caja blanca)
image:JugueteBloqueConstruccion.png["Hierarchy of building blocks"]

Seguimos la misma estructura que con el usuario, se define el esquema de la entidad en el ModeloJuguete, el cual es utilizado por el RepositorioJuguete que a su vez es llamado desde el routerJuguete ya que las peticiones requieren operaciones con acceso a datos (encontrar, añadir, etc).
En este caso el router también hace uso de la interfaz externa Cloudinary. Esta se encargará de cuando se añade un juguete, coger su imagen y guardarla en su almacén. Clodinary nos devolverá una URL propia que será el direccionamiento de la imagen que ha almacenado y que usaremos para el juguete.

=== Pedido (caja blanca)
image:PedidoBloqueConstruccion.png["Hierarchy of building blocks"]

Volvemos con la misma estructura, ModeloPedido define el esquema el pedido con sus atributos y restricciones que poseerá en la base de datos. Este modelo es necesario para realizar operaciones de acceso a datos, y por tanto, será requerido desde RepositorioPedido. Finalmente este es utilizado de routerPedido ya que peticiones como encontrar, añadir pedidos, etc, necesitan realizar operaciones con la base de datos. Además de a este repositorio, routerPedido hace acceso también al RepositorioJuguete y RepositorioUsuario para por ejemplo buscar los juguetes de un pedido en concreto o encontrar los pedidos de un usuario específico.
En este caso el router hace acceso tambíen a una API externa que es GeoCode, import de "node-geocoder". Esta internamente recibe una dirección y puede trabajar con distintos proveedores, en nuestro caso openstreetmap. Si su base de datos encuentra la dirección especificada devolverá una serie de datos sobre la misma, como puede ser las coordenadas. Esto nos hace posible posteriormente calcular manualmente el precio por km entre dos direcciones.
